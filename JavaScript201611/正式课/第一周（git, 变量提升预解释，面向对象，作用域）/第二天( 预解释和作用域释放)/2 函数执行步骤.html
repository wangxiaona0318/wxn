<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
</html>
<script>
    /*
    *   函数执行的步骤： 只要有代码运行就需要提供一个运行环境。而这个运行环境我们又可以叫做作用域。这是一个栈内存
    *       1 形成一个私有作用域。形参赋值 => 把实参所代表的值赋值给形参(如果是引用数据类型，切记是把实参所代表的地址赋值给形参一个)
    *       2 预解释当前作用域内所有带var和function的
    *       3 代码逐行执行
    *
    * */

    var num = 100;
    function fn(num){
        //console.log(num); // var num = 10;
        //var num = 1000; 这个var没用。因为这个私有变量和形参num是相同的。在形参赋值阶段就已经相当于声明过num了，并且还赋值了。所以在预解释阶段就没有必要重复声明num
        var total = 100;
        return function (){
            console.log(num);
        }
    }
    var res = fn(10);
    res(); // 100 10
    console.log(res); //functin (){ console.log(num) }
    console.log(res()); //undefined
    //res(); //只要函数执行每次形成的都是新的私有作用域
    /*
    *   作用域链: res函数就是fn(10)执行完的返回值，而fn执行之后的结果就是return的fn里面的函数。res在执行的时候却要打印num，然后自己私有作用域内并没有num，而是打印的fn(也就是包含res函数的fn)的形参num的值。如果fn没有num那么就去window全局查找。如果还没有那么就报错了。这种从函数定义的位置逐渐到上一级作用域的查找的过程可以理解为是一个链条关系。所以叫作用域链
    *   如何查找上一级作用域：函数执行的时候(是执行)上一级作用域就是看函数定义的位置。和函数在哪里执行没关系。
    *
    * */

    /*
    *   闭包: 目的就是把一个变量保护起来，不受外界干扰。
    *         在函数执行的时候，会形成一个新的私有的作用域。并且这个作用域内的变量都是私有变量在外界是不能访问的。我们把这种私有作用域保护私有变量不收外界干扰的机制就叫做闭包。闭包是在函数执行的时候才会产生的！！！，不执行都没有私有作用域更谈不上闭包了。
    *
    *
    *
    * */





</script>